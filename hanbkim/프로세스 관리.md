# 프로세스 관리

### 프로그램의 실행 (메모리 load)

프로그램이 실행되면 메모리에 올라가서 프로세스가 된다.

이 작업 중간에 한 가지 단계가 더 있다. → 버추얼 메모리

프로그램이 실행될 떄는 그 프로그램만의 주소 공간 address space 이 만들어진다. == 버추얼 메모리

그래서 각각의 프로세스는 자신만의 주소 공간이 0번지부터 존재한다. 
프로그램을 실행할 때 당장 필요한 부분은 물리적 메모리에 올라가고, 그렇지 않은 부분들은 디스크의 스왑 영역에 올라간다.

버추얼 메모리는 stack, data, code 세 영역으로 이루어진다.

- code
cpu가 읽을 기계어 부분이 저장된다.
- data
전역변수나 프로그램이 시작돼서 종료될 떄 까지 남아있을 데이터들이 저장된다.
- stack
함수 안에 있는 지역 변수들이 stack 영역에 저장된다. 함수의 호출, 리턴 등 관련된 정보를 스택에 차곡차곡 쌓아둬서 사용한다. (stack overflow)

heap는 어디에?? → stack이랑 같이 있음

커널도 마찬가지로 stack, data, code 세 영역으로 나뉜다.

### 커널 주소 공간의 내용

- code 
시스템콜, 인터럽트 처리 코드, 자원 관리를 위한 코드, 서비스 제공을 위한 코드 등을 가지고 있다.
- data
모든 프로세스들을 관리하기 위한 자료구조를 갖고있다.(PCB process control block)
- stack
커널의 스택은 각 프로세스마다 별도로 두고있다. 커널 함수에 관련된 스택..? 스택 구조로 되어있는데 여러개 쌓여있으면 어떻게 하는건지??? 스택이 여러개? 하나의 스택에 여러개의 프로세스?

### 사용자 프로그램이 사용하는 함수

1. 사용자 정의 함수
2. 라이브러리 함수

위 두개는 내 코드에 쓰이고, 프로세스의 가상 메모리 code 영역에 들어있다.

1. 커널 함수 (시스템 콜)

내 코드에 쓰여있지만 커널의 가상 메모리 code 영역에 들어있다. 커널에 있는걸 가져다 쓰는 것이다. 이 때 cpu 제어권이 커널로 넘어간다.

### 프로그램의 실행 과정

라이브러리 함수나 사용자 정의 함수를 실행한다면 user mode에서 실행된다.
시스템 콜 함수를 요청하면 kernel 모드로 바뀌어 운영체제의 메모리 공간에 있는 코드가 실행되는 것이다.

### 프로세스의 개념

⇒ 실행중인 프로그램

프로세스의 문맥?

→ 프로그램의 출생에서 사망까지.. 프로그램의 모든 것. 프로그램도 유년기, 청년기, 노년기를 지날텐데 현재 어떤상태에 있는지를 나타내는 것
과거에 cpu를 얼마나 썼나, 메모리를 얼마나 가졌나, 파일을 몇개나 쓰고 읽었나 이런 상태들을 프로세스의 문맥이라고 부른다.

1. cpu 수행 상태를 나타내는 하드웨어 문맥
Program Counter
각종 레지스터…
2. 프로세스의 주소 공간
code, data, stack
3. 프로세스 관련 커널 자료구조
PCB (Process Control Block)
Kernel stack

운영체제는 프로세스의 문맥을 굉장히 중요하게 생각한다.

### 프로세스의 상태

cpu는 하나이기 때문에 cpu에서 기계어를 실행하고 있는 프로세스는 매 순간 하나다. 
→ 그 프로세스를 Running 상태 라고 부른다.

cpu를 사용하기위해 모든 준비를 마치고 대기하고 있는 프로세스 (이 때 메모리 영역에 올라간다.)
→ Ready 상태라고 한다. 
(Ready queue에 들어감)

cpu를 할당해봐야 실행할 수 없는 상태인 프로세스도 있다. (ex : 아직 IO 처리를 받지 못한 상태)
→ Blocked 상태 (wait, sleep)

New → 프로세스가 생성중인 상태

Terminated → 실행이 끝난 상태

Suspended (stopped)
→ 외부적인 이유로 프로세스의 수행이 정지된 상태 (linux crtl + z)
(사용자가 프로그램을 일시 정지 시켰거나, 시스템이 여러 이유로 프로세스를 잠시 중단시켰을 경우)
프로세스는 통째로 디스크에 swap out된다.

모든 프로세스는 커널의 메모리 공간 data 영역에 PCB 형태로 저장된다.

프로세스가 blocked 상태일때는 어디에 보관되어있는지?

### Process Control Block (PCB)

운영체제가 프로세스를 관리하기 위해 프로세스당 유지하는 정보

구조체로 담고있다.

1. OS가 관리상 사용하는 정보
Process state, Process ID (PID)
scheduling information, priority (현대의 리눅스는 타이머뿐 아니라 프로세스의 우선순위를 계산해서 인터럽트를 건다)
2. CPU 수행 관련 하드웨어 값
Program counter, registers
3. 메모리 관련
Code, data, stack의 위치 정보
4. 파일 관련
Open file discrupter

### 문맥 교환  (Context Switch)

프로세스와 PCB 둘다 program counter, register를 가지고 있다.
프로세스는 cpu의 program counter, register를 갖고있고 PCB는 커널의 것을 가지고 있다. 
→ 왜냐하면 CPU를 얻었다가 뺐겼다가 반복을 하는데, 다음에 다시 얻었을 때 어느 시점부터 다시 실행해야 되는지 (프로세스의 문맥을) PCB에 저장해두는 것이다.

System call이나 interrupt 발생 시 반드시 문맥 교환이 일어나는 것은 아니다. 인터럽트가 일어나도 CPU가 같은 프로세스를 실행하고 있다면 문맥  교환이 아니다.

### 프로세스를 스케줄링하기 위한 큐

- Job queue
현재 시스템 내에 있는 모든 프로세스 집합 (현재에는 필요없는거같은데?)
- Ready queue
메모리 내에 있으며 CPU를 기다리고 있는 프로세스 집합
- Device queue
 I/O device의 처리를 기다리는 프로세스의 집합 (블럭상태)

프로세스들은 각 큐를 오가며 수행된다.

### 스케줄러 (Scheduler)

- Long-term schduler (장기 스케줄러 or job scheduler)
시작 프로세스 중 어떤 것들을 ready queue에 보낼지 결정한다.
→ 프로세스가 생성될 때 어떤 처리가 되는데, 프로세스가 처음 시작될 때 메모리에 올라오도록 허락해주는 행동을 함
time sharing system에는 보통 장기 스케줄러가 없다. 무조건 ready상태로 만듬
(우리가 아는 운영체제 대부분 없음)
- Short-term schduler (단기 스케줄러 or CPU scheduler)
어떤 프로세스를 다음번에 running 시킬지 결정한다.
milisecond 단위로 수행된다.
- Medium-term schduler (중기 스케줄러 or Swapper)
여유 공간 마련을 위해 프로세스를 통쨰로 메모리에서 디스크로 쫓아냄
프로세스에게서 memory를 뻇는다.
degree of multiprogramming을 제어

![스크린샷 2022-09-13 오후 11.50.01.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20dada3acb659540fa8cf9aa62eb4dacde/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.50.01.png)

### 프로세스의 개념

running, ready, blocked 등의 상태는 프로세스의 상태지, **운영체제**의 상태는 아니다. 운영체제(커널)이 레디, 블럭, 러닝되고있다고 말하진 않는다.

프로세스 a가 시스템콜 함수를 호출했을 때 운영체제에게 cpu가 넘어간다. 이 때 a는 cpu를 빼앗겼다기보다는 a가 여전히 실행중이라고 봐야하는것이 맞다. (여전히 **running 상태**)

그래서 프로세스 running 상태는 **user mode Running**, **monitor mode running** 두 개로 구분한다.

9/13 junji님과 대화
프로세스 a가 수행중이다가 b 프로세스의 io 인터럽트가 발생해 운영체제에게 cpu가 넘어가면 그것은 a가 실행중인거냐? b가 실행중인거냐?
→ a가 실행되던 중이고, 커널에게 cpu를 뺏겼지만 여전히 a가 러닝중인 상태라고 봐야한다. 그렇게 간주하는 것이다.

디스크에서 i/o를 요청하면 이것은 소프트웨어 인터럽트인가 하드웨어 인터럽트인가?

→ 둘 다라고 볼 수 있다. 소프트웨어가 시스템콜 함수를 불렀기때문에 소프트웨어 인터럽트가 발생한다. 그후 처리된 io를 cpu에게 알리기 위해 하드웨어 인터럽트가 발생한다.

### Thread

동일한 프로그램 여러개를 띄워놓으면, 같은 동작을 할텐데 여러 프로세스를 차지해 공간 낭비가 심할것이다.

그래서 프로세스마다 cpu 수행과 관련된 부분만 별도로 가지고 있고 (이걸 Thread라고 한다.) 그 외의 것들은 단일 프로세스로 공유한다.

![스크린샷 2022-09-13 오후 11.56.45.png](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20dada3acb659540fa8cf9aa62eb4dacde/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-09-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.56.45.png)

크롬 웹브라우저는 쓰레드로 하면 보안 문제가 생겨 여러 프로세스를 띄우는 방식이다. 프로그램의 구현마다 쓰레드를 쓸건지, 프로세스를 새로 띄울건지 구현 차이가 있다.

- 쓰레드의 구성
    - program counter
    - register set
    - stack space
    
- 쓰레드가 동료 쓰레드와 공유하는 부분 ( == task)
    - code selection
    - data selection
    - os resource
    

프로세스가 하나의 쓰레드로 이루어져있으면 무거운 프로세스라고 볼 수 있다.

- 다중 쓰레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 block 상태인 동안에도 동일한 태스크 내의 다른 스레드가 running되어 빠른 처리를 할 수 있다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.
- 병렬성을 높일 수 있다.

동기, 비동기.. 쓰레드..

### Benefits of Therads

- 응답성
ex ) 멀티 쓰레드 웹
- 자원을 공유하기 떄문에 효율적이고 경제적이다.
프로세스 하나를 만드는게 스레드 하나를 만드는 것에 비해서 solaris 운영체제의 경우 오버헤드가 30배, 컨텍스트 스위치 발생경우 5배 차이난다.

### Implementation of Thread

- 운영체제가 쓰레드를 알고 있는 경우 → Kernel threads
- 운영체제가 쓰레드를 모르고 있음 → User Threads
이경우 하나의 프로세스처럼 보여서 운영체제는 쓰레드에 관여하지 않는다.

운영체제의 구현에 따라 다르다..

- 부모 프로세스가 자식 프로세스 생성한다. 
→ 부모 프로세스가 fork() 시스템콜 함수를 호출해 운영체제가 만든다.

### 프로세스 생성

- 프로세스는 트리 구조로 형성된다.
- 프로세스는 자원을 필요로 하는데, 운영체제로부터 할당받는다.
- 자원의 공유
    - 부모와 자식이 모든 자원을 공유하는 모델
    - 일부를 공유하는 모델
    - 전혀 공유 x
- 수행 (execution)
    - 부모와 자식은 공존하며 수행되는 모델
    - 자식이 종료될 때 까지 부모가 기다리는 모델
- 주소 공간
    - 자식은 부모의 공간을 복사한다. (code, data, stack 모두 그대로 복사함)
    - 자식은 그 공간에 새로운 프로그램을 올린다.

유닉스의 경우..

1. fork () 시스템콜이 새로운 프로세스를 생성한다.
2. 부모를 그대로 복사해 주소 공간을 할당한다.
3. fork 다음에 이어지는 exec() 시스템콜을 통해 새로운 프로그램을 메모리에 올린다.

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알린다. (exit)
    - 자식이 부모에게 output data를 보낸다. (via wait)
    - 프로세스의 자원이 운영체제에게 반환된다.
    
- 부모 프로세스가 자식의 수행을 종료시킨다. (abort)
    - 자식이 할당된 자원의 한계치를 넘어섰거나, 할당된 태스크가 더이상 필요하지 안흘 경우
    - 부모가 exit하는 경우
        - 부모 프로세스가 종료하는 경우 자식이 더이상 수행되도록 두지 안흔다.
        - 단계적인 종료
    

### fork()

fork 함수가 호출된 부분부터 자식 프로세스가 작동한다. 

fork의 return값은 부모는 양수 (자식 프로세스의 pid) , 자식은 0을 갖는다.

운영체제도 fork를 통한 계층 구조로 되어있다.

### exec()

execlp(”/bin/date”, “bin/date”, (char *) 0);
 (프로그램 이름 두 번, 다음부터는 프로그램에 넣을 인자, 널포인터로 끝을 알림)
왜 프로그램 이름을 두번넣을까?

날짜와 데이터를 출력해주는 리눅스 프로그램이다. 위 명령어를 사용하면 현재 프로세스에 위의 프로그램이 완전히 덮어 씌워진다.

exaeclp로 프로그램을 실행 후 원래의 프로세스로 돌아가는 게 아니라 그 프로그램의 종료 시점에 프로세스가 종료된다.

### wait()

fork()함수를 사용하고 반환값이 양수인 프로세스에서 (부모 프로세스) , wait()함수를 사용하면 그 프로세스를 block 상태로 만든다. 자식 프로세스가 실행 종료되면 깨어난다.

리눅스에서 사용하는 쉘도 하나의 프로세스다. 명령어를 실행했을 때, 그 명령어가 자식프로세스가 되고 쉘은 wait 상태에 빠진다. 커맨드가 종료됐다면 다시 깨어난다.

wait 함수를 사용하지 않으면 부모와 자식은 컴퓨터 자원을 경쟁하는 상대다.

### exit()

프로세스의 종료

- 자발적 종료
    - 마지막 statement 수행 후 exit() 시스템콜을 통해 종료
    - 프로그램에 명시적으로 적어주지 않아도 main함수 return  후에 컴파일러가 넣는다.
- 비자발적 종료
    - 부모 프로세스가 자식 프로세스를 강제 종료시킨다.
    → 자식 프로세스가 한계치를 넘어선 자원 요청을 하거나, 자식에게 할당된 태스크가 더이상 필요하지 않을 때
    - 키보드로 kill, break등을 입력한 경우
    - 부모가 종료하는 경우
        
        
    

### 프로세스간 협력

프로세스는 만들어놓으면 각자의 주소 공간에서 독립적으로 실행된다. (원칙적으로 다른 프로세스의 수행에 침범하지 못한다)

그러나 **프로세스간 협력 매커니즘  IPC (interprocess communication)**을 통해 협력할 수 있다.

1. 메세지를 전달하는 방법 message passing
→ 커널을 통해 메세지 전달한다. 
메세지 큐로 프로세스에게 전달하고 받는 방법, 메일박스(또는 포트)에 넣어 전송하는 방법 두 가지가 있다.
2. 주소 공간을 공유하는 방법 shared memory
→ 신뢰할 수 있는 프로세스여야 한다. 
3. thread 
→ 하나의 프로세스이므로 프로세스간 협력으로 보기는 어렵지만,
동일한 process를 구성하는 thread간에는 주소 공간을 공유해 협력한다.
4. pipe통신….