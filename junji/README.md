# 운영체제
- `컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층`으로서 모든 컴퓨터 시스템의 필수적인 부분이다. 본 강좌에서는 `운영체제의 개념과 역할`, `운영체제를 구성하는 각 요소` 및 `그 알고리즘의 핵심적인 부분`에 대해 기초부터 학습한다.

- 운영체제 개요
- 컴퓨터시스템의 구조
- 프로세스 관리
- CPU 스케줄링
- 병행 제어
- 데드락
- 메모리 관리
- 가상 메모리
- 파일 시스템
- 입출력 시스템
- 디스크 관리

# [2강. 운영체제 개요2]
> Keyword
```
CPU Scheduling(FCFS, SJF, RR)
Memory Management                 <today>
-------------------------------- 
Disk Scheduling
	- 구성
	- FCFS, SSTF, SCAN
저장장치 계층 구조
캐싱
플래시 메모리
```
> Question
```
가상 메모리는 무엇이고 왜 필요할까?
```
> 가상메모리
```
초기 컴퓨터에선 응용 프로그램의 크기가 사용가능한 RAM크기보다 큰 경우가 많았다. '메모리 부족'을 해결하기 위한 다양한 시도가 있었고, 그 중에는 '오버레이 기법', '가상 메모리 기법'이 있다. 

'오버레이 기법'은 전체 프로그램을 몇개의 모듈로 나누어 컴파일하고, 필요한 모듈만 메모리에 올리는 방식이다. 용량이 큰 프로그램을 부분으로 나눈 뒤 필요할 때마다 이를 꺼내오는 방식인데, 학생 성적을 처리하는 프로그램이라면 (데이터 입력)(데이터 연산)(인쇄) 등의 세그먼트로 나누어 순차적으로 실행되게 한다. (프로그램을 각 모듈로 나누고 그 모듈간의 데이터 교환을 실행시켜야하는 작업을 요한다)

기존에는 프로세스가 실행되는 코드의 전체를 메모리에 로드해야 했고, 메모리 용량보다 더 큰 프로그램은 실행시킬 수 없었다. 하지만 실제로 코드의 일부에서만 대부분의 시간을 사용하고, 프로세스는 특정 순간에는 항상 작은 양의 주소 공간을 사용했기에 이런 방식은 비효율적이었다.

'가상 메모리'란 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 둔다. 이를 통해 프로세스 전체가 물리적 메모리에 있는 것처럼 보인다. 결과적으로 메모리에 작은 양의 주소 공간만 있으면 충분히 프로세스를 수행할 수 있다.

```
> 참고자료
- https://rebro.kr/179

# CPU 스케쥴링
### FCFS (First Come First Served)
- Waiting time
- Average wating time 

### SJF (Shortest-Job-First)
- 금번 cpu 사용시간이 가장 짧은 프로세스를 제일 먼저 스케쥴
- SJF는 `minimum average waiting time`을 보장한다.
- Starvation(기아 현상)발생 가능. (형평성에 문제)

### Round Robin (RR)
- 각 프로세스 동일 크기의 CPU 할당시간을 가짐
- 할당시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고 CPU큐의 제일 뒤에 줄을 선다.
- n개의 프로세스가 CPU 큐에 있는 경우
	- 어떤 프로세스도 (n-1)*할당시간 이상 기다리지 않음
	- 대기시간이 프로세스의 CPU 사용시간에 비례

### 메모리 관리
- 프로그램을 실행시키면 그것을 실행시킬 독자적인 메모리 주소가 부여되고 그것이 바로 물리적인 메모리에 올라가는 것이 아니라 본인만의 가상 메모리에 만들어진다. 실제 메모리는 당장 필요한 부분만 가상메모리에서 가져와 사용하게 된다.
- 디스크(파일시스템, 스왑영역)
- 메모리 다 찼을 때 swap영역으로 쫓아낸다. (메모리의 연장 공간이다, 컴퓨터가 꺼지면 메모리 사라짐, swap영역은 살아있지만 의미 없는 정보이다)
- 쪼개지는 단위를 page. 어떤 page를 메모리에서 쫓아낼 것인가?
	- 미래를 모르는 상황에서 다시 사용하지 않을 확률이 높은 페이지를 swap영역으로 쫓아낸다.
	- 미래를 모를 때 과거를 본다.
- LRU(가장 오래 전에 참조 페이지 삭제)
- LFU(참조횟수가 가장 적은 페이지 삭제)

### 디스크 스케쥴링
- 디스크 큐
- 디스크 스케쥴링을 효율적으로 하는 핵심은 디스크 헤드의 이용(디스크 접근 비용 크다)을 최대한 줄이는 것이다.
- 디스크 접근 시간의 구성
	- 탐색시간(seek time)
		- 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간
	- 회전지연(rotation latency)
		- 헤드가 원하는 섹터에 도달하기 전까지 걸리는 시간
	- 전송시간(transfer time)
		- 실제 데이터의 전송 시간
- 디스크 스케쥴링(disk scheduling)
	- seek time을 최소화하는 것이 목표.
	- sekk time ~ seek distance
		- FCFS
		- SSTF(Shortest Seek Time First)
			- stravation 문제
		- SCAN
			- 헤드가 디스크 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.
			- 다른 한쪽 끝에 도달하면 역방향으로 이동하여 오는 길목에 있는 요청을 처리하며 다시 반대쪽 끝으로 이동한다. (엘리베이터 스케쥴링 scan에 근간)

### 저장장치 계층구조와 캐싱(caching)
- Register
- Cache Memory
- Main Memory      <primary> : CPU직접 접근 가능
--- 
- Magnetic Disk    <secondary>
- Optical Disk
- Magnetic Tape
#### 계층 구조: 속도 차이를 완화하기 위해서.
#### 캐싱(caching): copying information into faster storage system

### 플래시메모리
- 반도체 장치(하드디스크: 마그네틱)
- NAND형(스토리지), NOR형(임베디드 코드 저장용)
- 특징
	- Nonvolatile
	- Low power consumption
	- shock resistance
	- small size
	- Lightweight
	- 쓰기 횟수 제약
		- 골고루 플래시 메모리를 사용할 수 있도록 하게끔(software)
	- 데이터 변질 위험(오랜 시간이 지나면 셀에 최소 전하량 빠지면서 1이란 데이터가 0으로 바뀔 수 있음)
		- 일정시간이 지나면 전하량을 다시 채워주기 위에 옮겨쓰기를 한다던지(software)
- 플래시 메모리의 사용 형태
	- 휴대폰, PDA 등 임베디드 시스템 구성용
	- USB용 메모리 스틱
	- 디지털카메라 등의 SD카드, CompactFlash, Smart Mediacard
	- 모바일 장치 뿐 아니라 대용량 시스템에서 SSD(Solid State Drive)란 이름으로 하드디스크 대체 시도

### 운영체제의 종류 
#### 오픈소스 개발자들은 어떻게 먹고 사는가?

# [1강. 운영체제 개요]

> keyword
```
운영체제
운영체제의 목적
CPU
컴퓨터 시스템 구조
운영체제 기능
인터럽트
캐싱
```

# 운영체제(Operating System, OS)란?
- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
```
[사용자][사용자]
[각종 소프트웨어][사용자]
[운영체제]
[컴퓨터하드웨어]
```

# 운영체제의 목적
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
	- 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상(illusion)을 제공
	- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
- 컴퓨터 시스템의 `자원(resource)을 효율적으로 관리`
	- `CPU, 메모리, I/O 장치` 등의 효율적 관리
		- 주어진 자원으로 최대한의 성능을 내도록 -> `효율성`
		- 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 -> `형평성`
	- 사용자 및 운영체제 자신의 보호

```실행중인 프로그램들에게 짧은 시간의 CPU를 번갈아 할당```
```개별 프로세스는 자신이 CPU를 독점하고 있다고 생각```
```클라이언트는 서버를 자기가 혼자 사용하고 있다고 생각```
```CPU 연산속도가 매우 빠르기 때문에 컴퓨터 두뇌```
```기가 헤르츠, 초당 클럭이 10억. 1초에 기계어를 10억개를```
```0.1초, 0.01초 차이를 사람을 느끼지 못한다. CPU는 여러 프로그램들을 0.1초 이내로 번갈아가며 실행을 하면 사람은 인지하기 어렵다```
```컴퓨터 메모리. 실행중인 프로그램들에 메모리 공간을 적절히 분배```

# 컴퓨터 시스템 구조
[컴퓨터 내부]           [입출력I/O 디바이스]
<CPU>                        <디스크>         input/output device
							 <키보드, 마우스> input device
                             <모니터, 프린트> output device
	<메모리>
    
```컴퓨터 전원을 켜면(부팅) 운영체제가 시스템 메모리에 올라간다```
```운영체제란 컴퓨터가 꺼지기 전까지 항상 실행되는 프로그램이다```
```운영체제 중에서 핵심이 되는 부분을 커널이라고 한다```
```cpu의 작업공간을 메모리공간이다```
```cpu는 매 순간(매 클럭) 메모리 어딘가에 있는 기계어를 읽어다가 연산을 한다```
```cpu가 직접 외부장치를 접근할 수 없다```
```cpu가 I/O device들에게 작은 cpu가 붙어있다. I/O Controller다. cpu가 I/O Controller에게 file을 읽어달라고 요청, controller는 요청된 file을 읽고 작은 메모리 공간에 읽게된다. cpu는 그 메모리를 읽는다``` 

```

### 운영체제의 기능
1. CPU 스케쥴링
	- 어떤 프로그램에게 CPU사용권을 줄까?

2. 메모리 관리
	- 한정된 메모리를 어떻게 쪼개어 쓰지?

3. 디스크 스케쥴링
	- 디스크에 들어온 요청을 어떤 순서로 처리할까?

짧은 CPU와 느린 I/O 장치간 속도 차이를 어떻게 극복하지?
(인터럽트, 캐싱)

인터럽트는 느린 장치에다 무언가 일을 시켜놓고, (게속 일을 끝났는지 확인하는 것은 비효율적)
CPU는 자기 할 일을 하고 있고, 느린 장치들에게 시킨 일이 끝나면 CPU에게 (CPU입장에서는 아주 가끔) 인터럽트를 걸어서
처리 사실을 알려주고 CPU의 제어권이 인터럽트에 의해서 자동으로 운영체제에 넘어가서 인터럽트 이후에 해당하는 일을 처리함.

CPU - 기계어 실행

