# 운영체제
- `컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층`으로서 모든 컴퓨터 시스템의 필수적인 부분이다. 본 강좌에서는 `운영체제의 개념과 역할`, `운영체제를 구성하는 각 요소` 및 `그 알고리즘의 핵심적인 부분`에 대해 기초부터 학습한다.

- 운영체제 개요
- 컴퓨터시스템의 구조
- 프로세스 관리
- CPU 스케줄링
- 병행 제어
- 데드락
- 메모리 관리
- 가상 메모리
- 파일 시스템
- 입출력 시스템
- 디스크 관리

# [3 ~ 4강. 컴퓨터 시스템 구조1 2]
> keyword
```
operating system
time sharing(시분할)
realtime(실시간)

multitasking
multiprogramming
multiprocess 
multiprocessor

operating system what to do
```

> 새롭게 알게 된 내용
```
굉장히 많은 프로그램이 실행 될 때 운영체제는 공평하게 분배하는 게 아니라 일정 프로그램에 집중적으로 메모리를 할당하고, 나머지 프로그램은 swap영역에 있게 된다. 한 프로그램이 충분히 실행되고 난 후(I/O입출력 등) 할당된 자원을 다른 프로그램에 분배한다. 이떄도 대개 집중적으로 메모리를 할당해준다.
```
- 좁은 의미의 운영체제는 커널(운영체제의 가장 핵심적인 부분, 메모리에 항상 상주하는 부분)
- 넓은 의미의 운영체제는 커널 뿐 아니라 각종 주변 시스템 유틸리티 포함하는 개념
- 컴퓨터 시스템의 `자원(resource)을 효율적으로 관리` --> 소프트웨어 자원도 포함된다.
- 컴퓨터의 두뇌는 운영체제가 아닐까? CPU는 단순히 연산이 빠르다. 기억을 하려면 memory가 필요하다. 판단능력은 없기 때문이다.
- 운영체제는 관리하는 역할이기에 판단을 하기에 두뇌역할을 한다. (통치자역할) 
- 누구한테 메모리를, 누구한테 cpu를 얼마나 줄까, 효율적, 공평하게. 
- 메모리 관리 ( 한정된 메모리 공간에 여러 프로그램이 동시에 올라감. 프로그램마다 메모리를 조금씩 나누어져야 한다) 
	- 무조건 공평하게 배분하면 어느 하나가 발전하지 못한다. (사회 지원제도와 비슷하다) 메모리도 이처럼 동작함. 
	- 메모리 관리. 굉장히 큰 많은 프로그램이 실행될 때 메모리 공간을 공평하게 n분의 1로 나누어 쓰는 게 아니라 특정 프로그램은 (swap)부분으로 쫓아내고, 특정 프로그램만 메모리를 많이 주는 경우가 있다. 많이 쓰고 있는 프로그램은 충분히 썼기에 I/O를 하러 떠난다. 그러면 그 친구의 메모리를 뺏어 다른 프로그램에 집중투자함. (몰아주는 게 훨씬 더 효율적)
- 운영 체제의 분류
	1. 동시 작업이 가능한지
		- multi tasking이 가능하다(동시에 2개이상 작업 처리)
	2. 사용자의 수
		- 단일, 다중(좀 더 복잡한 문제, ex - 보안 문제)
	3. 처리방식
		- 일괄처리(batch processing)
			- 작업 요청의 일정량 모아서 한꺼번에 처리
			- 작업이 완전 종료될 떄까지 기다려야함.
			- ex)punch card 처리 시스템
		- 시분할(time sharing)
			- 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간단위로 분할하여 사용.
			- 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
			- interactive한 방식
		- 실시간(realtime OS)
			- 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
			- ex) 원자로/ 공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
		- 실시간 시스템의 개념 확장
			- Hard realtime system(경성 실시간 시스템)
			- soft realtime system(연성 실시간 시스템)
- Multitasking (컴퓨터 안에 프로그램을 동시에 여러개 돌리는 거)
- Multiprogramming (메모리 측면 강조, 메모리에 여러 프로그램을 동시에 돌리는거)
- time sharing (시간을 쪼개서 쓴다, CPU강조)
- Multiprocess 
  - 다들 똑같은 얘기다. 
- Multiprocessor : 하나의 컴퓨터에 CPU가 여러개 붙어 있음.

### UNIX
- C
- 높은 이식성
- 최소한 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 오픈 소스
```c
원래는 하드웨어를 제어하고 싶으면 어셈블리어를 사용해야 했다. 효율적인 언어지만 사람이 이해하기는 어렵고, 아예 C언어를 만듬.

C언어 사람이 쓰기 쉽지만, 하드웨어를 다루기도 좋은 언어.
```

### MS_DOS (Disk operating system)
- 개인적 컴퓨터를 위한 컴퓨터. 단일 사용자 운영체제. 메모리 관리 능력 한계(주 기억장치 640kb)

### 운영체제의 구조
- CPU 스케쥴링
- 메모리 관리
- 발열 관리
- 입출력 관리(각기 다른 입출력장치와 컴퓨터간에 어떻게 정보를 주고 받게 하지?)
- 프로세스 관리
	- 프로세스의 생성과 삭제
	- 자원 할당 및 반환
	- 프로세스간 협력
- 그 외 (보호시스템, 네트워킹, 명령어해석기)

- 이 수업을 OS사용자 관점이 아니라 OS 개발자 관점에서 수강해야 한다.
	- 대부분 알고리즘은 OS 프로그램 자체의 내용
	- 인간의 신체가 뇌의 통제 받듯 컴퓨터 하드웨어는 운영체제의 통제를 받으며, 그 운영체제는 사람이 프로그래밍
	- 본인이 window xp나 linux같은 운영체제라고 생각하고 본인이 할 일이 무엇인지를 생각해보면 앞으로 배울 내용을 명확히 알 수 있다.
# [2강. 운영체제 개요2]
> Keyword
```
CPU Scheduling(FCFS, SJF, RR)
Memory Management                 <today>
-------------------------------- 
Disk Scheduling
	- 구성
	- FCFS, SSTF, SCAN
저장장치 계층 구조
캐싱
플래시 메모리
```
> Question
```
가상 메모리는 무엇이고 왜 필요할까?
```
> 가상메모리
```
초기 컴퓨터에선 응용 프로그램의 크기가 사용가능한 RAM크기보다 큰 경우가 많았다. '메모리 부족'을 해결하기 위한 다양한 시도가 있었고, 그 중에는 '오버레이 기법', '가상 메모리 기법'이 있다. 

'오버레이 기법'은 전체 프로그램을 몇개의 모듈로 나누어 컴파일하고, 필요한 모듈만 메모리에 올리는 방식이다. 용량이 큰 프로그램을 부분으로 나눈 뒤 필요할 때마다 이를 꺼내오는 방식인데, 학생 성적을 처리하는 프로그램이라면 (데이터 입력)(데이터 연산)(인쇄) 등의 세그먼트로 나누어 순차적으로 실행되게 한다. (프로그램을 각 모듈로 나누고 그 모듈간의 데이터 교환을 실행시켜야하는 작업을 요한다)

기존에는 프로세스가 실행되는 코드의 전체를 메모리에 로드해야 했고, 메모리 용량보다 더 큰 프로그램은 실행시킬 수 없었다. 하지만 실제로 코드의 일부에서만 대부분의 시간을 사용하고, 프로세스는 특정 순간에는 항상 작은 양의 주소 공간을 사용했기에 이런 방식은 비효율적이었다.

'가상 메모리'란 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 둔다. 이를 통해 프로세스 전체가 물리적 메모리에 있는 것처럼 보인다. 결과적으로 메모리에 작은 양의 주소 공간만 있으면 충분히 프로세스를 수행할 수 있다.

```
> 참고자료
- https://rebro.kr/179

# CPU 스케쥴링
### FCFS (First Come First Served)
- Waiting time
- Average wating time 

### SJF (Shortest-Job-First)
- 금번 cpu 사용시간이 가장 짧은 프로세스를 제일 먼저 스케쥴
- SJF는 `minimum average waiting time`을 보장한다.
- Starvation(기아 현상)발생 가능. (형평성에 문제)

### Round Robin (RR)
- 각 프로세스 동일 크기의 CPU 할당시간을 가짐
- 할당시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고 CPU큐의 제일 뒤에 줄을 선다.
- n개의 프로세스가 CPU 큐에 있는 경우
	- 어떤 프로세스도 (n-1)*할당시간 이상 기다리지 않음
	- 대기시간이 프로세스의 CPU 사용시간에 비례

### 메모리 관리
- 프로그램을 실행시키면 그것을 실행시킬 독자적인 메모리 주소가 부여되고 그것이 바로 물리적인 메모리에 올라가는 것이 아니라 본인만의 가상 메모리에 만들어진다. 실제 메모리는 당장 필요한 부분만 가상메모리에서 가져와 사용하게 된다.
- 디스크(파일시스템, 스왑영역)
- 메모리 다 찼을 때 swap영역으로 쫓아낸다. (메모리의 연장 공간이다, 컴퓨터가 꺼지면 메모리 사라짐, swap영역은 살아있지만 의미 없는 정보이다)
- 쪼개지는 단위를 page. 어떤 page를 메모리에서 쫓아낼 것인가?
	- 미래를 모르는 상황에서 다시 사용하지 않을 확률이 높은 페이지를 swap영역으로 쫓아낸다.
	- 미래를 모를 때 과거를 본다.
- LRU(가장 오래 전에 참조 페이지 삭제)
- LFU(참조횟수가 가장 적은 페이지 삭제)

### 디스크 스케쥴링
- 디스크 큐
- 디스크 스케쥴링을 효율적으로 하는 핵심은 디스크 헤드의 이용(디스크 접근 비용 크다)을 최대한 줄이는 것이다.
- 디스크 접근 시간의 구성
	- 탐색시간(seek time)
		- 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간
	- 회전지연(rotation latency)
		- 헤드가 원하는 섹터에 도달하기 전까지 걸리는 시간
	- 전송시간(transfer time)
		- 실제 데이터의 전송 시간
- 디스크 스케쥴링(disk scheduling)
	- seek time을 최소화하는 것이 목표.
	- sekk time ~ seek distance
		- FCFS
		- SSTF(Shortest Seek Time First)
			- stravation 문제
		- SCAN
			- 헤드가 디스크 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.
			- 다른 한쪽 끝에 도달하면 역방향으로 이동하여 오는 길목에 있는 요청을 처리하며 다시 반대쪽 끝으로 이동한다. (엘리베이터 스케쥴링 scan에 근간)

### 저장장치 계층구조와 캐싱(caching)
- Register
- Cache Memory
- Main Memory      <primary> : CPU직접 접근 가능
--- 
- Magnetic Disk    <secondary>
- Optical Disk
- Magnetic Tape
#### 계층 구조: 속도 차이를 완화하기 위해서.
#### 캐싱(caching): copying information into faster storage system

### 플래시메모리
- 반도체 장치(하드디스크: 마그네틱)
- NAND형(스토리지), NOR형(임베디드 코드 저장용)
- 특징
	- Nonvolatile
	- Low power consumption
	- shock resistance
	- small size
	- Lightweight
	- 쓰기 횟수 제약
		- 골고루 플래시 메모리를 사용할 수 있도록 하게끔(software)
	- 데이터 변질 위험(오랜 시간이 지나면 셀에 최소 전하량 빠지면서 1이란 데이터가 0으로 바뀔 수 있음)
		- 일정시간이 지나면 전하량을 다시 채워주기 위에 옮겨쓰기를 한다던지(software)
- 플래시 메모리의 사용 형태
	- 휴대폰, PDA 등 임베디드 시스템 구성용
	- USB용 메모리 스틱
	- 디지털카메라 등의 SD카드, CompactFlash, Smart Mediacard
	- 모바일 장치 뿐 아니라 대용량 시스템에서 SSD(Solid State Drive)란 이름으로 하드디스크 대체 시도

### 운영체제의 종류 
#### 오픈소스 개발자들은 어떻게 먹고 사는가?
```c
소프트웨어 상품의 특이한 성질.
만드는데 인건비가 드나, 추가적으로 파는 비용은 거의 없다.
독점체제가 가능한 시장.
사실 공개소프트웨어 개발자는 2등이었던 것.
소프트웨어 교육시장, 컨설팅, 명예, 버그를 잡으며 더 탄탄한 프로그램.
지금은 소프트웨어의 특수성이 오히려 강력한 무기가 되는.
```

# [1강. 운영체제 개요]

> keyword
```
운영체제
운영체제의 목적
CPU
컴퓨터 시스템 구조
운영체제 기능
인터럽트
캐싱
```

# 운영체제(Operating System, OS)란?
- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
```
[사용자][사용자]
[각종 소프트웨어][사용자]
[운영체제]
[컴퓨터하드웨어]
```

# 운영체제의 목적
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
	- 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상(illusion)을 제공
	- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
- 컴퓨터 시스템의 `자원(resource)을 효율적으로 관리` --> 소프트웨어 자원도 포함된다.
	- `CPU, 메모리, I/O 장치` 등의 효율적 관리
		- 주어진 자원으로 최대한의 성능을 내도록 -> `효율성`
		- 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 -> `형평성`
	- 사용자 및 운영체제 자신의 보호

```실행중인 프로그램들에게 짧은 시간의 CPU를 번갈아 할당```
```개별 프로세스는 자신이 CPU를 독점하고 있다고 생각```
```클라이언트는 서버를 자기가 혼자 사용하고 있다고 생각```
```CPU 연산속도가 매우 빠르기 때문에 컴퓨터 두뇌```
```기가 헤르츠, 초당 클럭이 10억. 1초에 기계어를 10억개를```
```0.1초, 0.01초 차이를 사람을 느끼지 못한다. CPU는 여러 프로그램들을 0.1초 이내로 번갈아가며 실행을 하면 사람은 인지하기 어렵다```
```컴퓨터 메모리. 실행중인 프로그램들에 메모리 공간을 적절히 분배```

# 컴퓨터 시스템 구조
[컴퓨터 내부]           [입출력I/O 디바이스]
<CPU>                        <디스크>         input/output device
							 <키보드, 마우스> input device
                             <모니터, 프린트> output device
	<메모리>
    
```컴퓨터 전원을 켜면(부팅) 운영체제가 시스템 메모리에 올라간다```
```운영체제란 컴퓨터가 꺼지기 전까지 항상 실행되는 프로그램이다```
```운영체제 중에서 핵심이 되는 부분을 커널이라고 한다```
```cpu의 작업공간을 메모리공간이다```
```cpu는 매 순간(매 클럭) 메모리 어딘가에 있는 기계어를 읽어다가 연산을 한다```
```cpu가 직접 외부장치를 접근할 수 없다```
```cpu가 I/O device들에게 작은 cpu가 붙어있다. I/O Controller다. cpu가 I/O Controller에게 file을 읽어달라고 요청, controller는 요청된 file을 읽고 작은 메모리 공간에 읽게된다. cpu는 그 메모리를 읽는다``` 

```

### 운영체제의 기능
1. CPU 스케쥴링
	- 어떤 프로그램에게 CPU사용권을 줄까?

2. 메모리 관리
	- 한정된 메모리를 어떻게 쪼개어 쓰지?

3. 디스크 스케쥴링
	- 디스크에 들어온 요청을 어떤 순서로 처리할까?

짧은 CPU와 느린 I/O 장치간 속도 차이를 어떻게 극복하지?
(인터럽트, 캐싱)

인터럽트는 느린 장치에다 무언가 일을 시켜놓고, (게속 일을 끝났는지 확인하는 것은 비효율적)
CPU는 자기 할 일을 하고 있고, 느린 장치들에게 시킨 일이 끝나면 CPU에게 (CPU입장에서는 아주 가끔) 인터럽트를 걸어서
처리 사실을 알려주고 CPU의 제어권이 인터럽트에 의해서 자동으로 운영체제에 넘어가서 인터럽트 이후에 해당하는 일을 처리함.

CPU - 기계어 실행

